
- Definition de d'un language de programmation orienté objet --> Python
- comment utiliser range, if, while, for, etc.

Pratique:
   [A] Ex1 Utiliser while pour afficher le prix TTC après sais du prix HT. doit se répéter tant que prix_HT diff de zero
   [A] Ex2 Utiliser for (ou while) pour vérifier si une liste est palindrome

## Algorithmique

- Algorithme = Liste d'instructions à suivre pour résoudre un problème
- Etapes pour écrire un algorithme : Phase préparatoire, traitement et sortie des résultats.

## Défis:

Proposer un petit programme en Python qui, à partir de la liste complète des personnes de Simplon (apprenants et équipe pédagogique incluse) tire au hasard deux noms pour proposer l'échange de cadeau.

Deadline : December 16th at 12:30


    [A] Phase préparatoire : Travail de groupe : Sabine, Amaria, Noémie et Romain
    We came up with two methods : Easy, fast and convenient AND more complex but fun to think about and implement. Let's call them methods 1 and 2.

    Method 1 :
     Entry = Full list of Simplon participants.
     Algorithm = The idea is to use the shuffle function in the random library to shuffle the entries of that same list. We obtain a new list where the first entry gives a gift the second and so on.
     Output = We would like to visualize the result in the form of two lists of "givers" and "takers". For this purpose, one can create a for loop in which for each entry i print i and i+1 next to each other. 


    Method 2:
     Entry = Full list of Simplon participants.
     Algorithm = The idea is to randomly choose participants from the original list and place them in a new list such that entry 'i' in original list gives a gift to corresponding entry 'i' in new list.
     Loaded into Python, the original list will already be indexed from 0 to n-1, n being the total number of participants. We use the function choice of the random library to choose an index from original list and fill it in the new list.
     However, two things are to be avoided : chosen index and index of place to be filled in new list should not be the same AND that an index previously chosen should not be repeated in the future. This translates to one cannot give a gift to one's self, and one cannot recieve more than one gift.
     --> First problem is adressed by including an if close where we ask the algorithm to repeat the choice in case chosen_index_original = index_new.
     --> Second problem is solved by adding another list, of same length as original (and new), that only accepts boolean values of "true" or "false", where true means "value" has been chosen and false means "value still has not been chosen". It will be initialized to all false. That way, at each random choice of index, the algorithm will go to the boolean table and check if at that index the value is true or false. if it's true, i.e. value already been chosen, it will try again. If false, it will accept the value and store it in the new table. Of course, it should update the corresponding value in boolean to "true".    
     Output = Original list (givers) vs. New list (takers) (evidently with names)
     
    
    [NA] Traitement :
    [NA] Sortie des résultats



